{"version":3,"file":"service-worker-edge-DFrdh3-w.js","sources":["../../../../node_modules/.pnpm/effect@3.18.0/node_modules/effect/dist/esm/Brand.js","../../../../submodules/livestore/packages/@livestore/common/src/schema/EventSequenceNumber.ts","../../../../submodules/livestore/packages/@livestore/common/src/schema/LiveStoreEvent.ts","../../../../submodules/livestore/packages/@livestore/common/src/errors.ts","../src/service-worker-edge.ts"],"sourcesContent":["/**\n * This module provides types and utility functions to create and work with branded types,\n * which are TypeScript types with an added type tag to prevent accidental usage of a value in the wrong context.\n *\n * The `refined` and `nominal` functions are both used to create branded types in TypeScript.\n * The main difference between them is that `refined` allows for validation of the data, while `nominal` does not.\n *\n * The `nominal` function is used to create a new branded type that has the same underlying type as the input, but with a different name.\n * This is useful when you want to distinguish between two values of the same type that have different meanings.\n * The `nominal` function does not perform any validation of the input data.\n *\n * On the other hand, the `refined` function is used to create a new branded type that has the same underlying type as the input,\n * but with a different name, and it also allows for validation of the input data.\n * The `refined` function takes a predicate that is used to validate the input data.\n * If the input data fails the validation, a `BrandErrors` is returned, which provides information about the specific validation failure.\n *\n * @since 2.0.0\n */\nimport * as Arr from \"./Array.js\";\nimport * as Either from \"./Either.js\";\nimport { identity, unsafeCoerce } from \"./Function.js\";\nimport * as Option from \"./Option.js\";\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const BrandTypeId = /*#__PURE__*/Symbol.for(\"effect/Brand\");\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const RefinedConstructorsTypeId = /*#__PURE__*/Symbol.for(\"effect/Brand/Refined\");\n/**\n * Returns a `BrandErrors` that contains a single `RefinementError`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const error = (message, meta) => [{\n  message,\n  meta\n}];\n/**\n * Takes a variable number of `BrandErrors` and returns a single `BrandErrors` that contains all refinement errors.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const errors = (...errors) => Arr.flatten(errors);\nexport function refined(...args) {\n  const either = args.length === 2 ? unbranded => args[0](unbranded) ? Either.right(unbranded) : Either.left(args[1](unbranded)) : unbranded => {\n    return Option.match(args[0](unbranded), {\n      onNone: () => Either.right(unbranded),\n      onSome: Either.left\n    });\n  };\n  return Object.assign(unbranded => Either.getOrThrowWith(either(unbranded), identity), {\n    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,\n    option: args => Option.getRight(either(args)),\n    either,\n    is: args => Either.isRight(either(args))\n  });\n}\n/**\n * This function returns a `Brand.Constructor` that **does not apply any runtime checks**, it just returns the provided value.\n * It can be used to create nominal types that allow distinguishing between two values of the same type but with different meanings.\n *\n * If you also want to perform some validation, see {@link refined}.\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Brand } from \"effect\"\n *\n * type UserId = number & Brand.Brand<\"UserId\">\n *\n * const UserId = Brand.nominal<UserId>()\n *\n * console.log(UserId(1))\n * // 1\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nominal = () => {\n  // @ts-expect-error\n  return Object.assign(args => args, {\n    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,\n    option: args => Option.some(args),\n    either: args => Either.right(args),\n    is: _args => true\n  });\n};\n/**\n * Combines two or more brands together to form a single branded type.\n * This API is useful when you want to validate that the input data passes multiple brand validators.\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Brand } from \"effect\"\n *\n * type Int = number & Brand.Brand<\"Int\">\n * const Int = Brand.refined<Int>(\n *   (n) => Number.isInteger(n),\n *   (n) => Brand.error(`Expected ${n} to be an integer`)\n * )\n * type Positive = number & Brand.Brand<\"Positive\">\n * const Positive = Brand.refined<Positive>(\n *   (n) => n > 0,\n *   (n) => Brand.error(`Expected ${n} to be positive`)\n * )\n *\n * const PositiveInt = Brand.all(Int, Positive)\n *\n * console.log(PositiveInt(1))\n * // 1\n *\n * assert.throws(() => PositiveInt(1.1))\n * ```\n *\n * @since 2.0.0\n * @category combining\n */\nexport const all = (...brands) => {\n  const either = args => {\n    let result = Either.right(args);\n    for (const brand of brands) {\n      const nextResult = brand.either(args);\n      if (Either.isLeft(result) && Either.isLeft(nextResult)) {\n        result = Either.left([...result.left, ...nextResult.left]);\n      } else {\n        result = Either.isLeft(result) ? result : nextResult;\n      }\n    }\n    return result;\n  };\n  // @ts-expect-error\n  return Object.assign(args => Either.match(either(args), {\n    onLeft: e => {\n      throw e;\n    },\n    onRight: identity\n  }), {\n    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,\n    option: args => Option.getRight(either(args)),\n    either,\n    is: args => Either.isRight(either(args))\n  });\n};\n/**\n * Retrieves the unbranded value from a `Brand` instance.\n *\n * @since 3.15.0\n * @category getters\n */\nexport const unbranded = unsafeCoerce;\n//# sourceMappingURL=Brand.js.map","import { Brand, Schema } from '@livestore/utils/effect'\n\nexport type ClientEventSequenceNumber = Brand.Branded<number, 'ClientEventSequenceNumber'>\nexport const localEventSequenceNumber = Brand.nominal<ClientEventSequenceNumber>()\nexport const ClientEventSequenceNumber = Schema.fromBrand(localEventSequenceNumber)(Schema.Int)\n\nexport type GlobalEventSequenceNumber = Brand.Branded<number, 'GlobalEventSequenceNumber'>\nexport const globalEventSequenceNumber = Brand.nominal<GlobalEventSequenceNumber>()\nexport const GlobalEventSequenceNumber = Schema.fromBrand(globalEventSequenceNumber)(Schema.Int)\n\nexport const clientDefault = 0 as any as ClientEventSequenceNumber\n\nexport const rebaseGenerationDefault = 0\n\n/**\n * LiveStore event sequence number value consisting of a globally unique event sequence number\n * and a client sequence number.\n *\n * The client sequence number is only used for client-local events and starts from 0 for each global sequence number.\n *\n * For event notation documentation, see: contributor-docs/events-notation.md\n */\nexport type EventSequenceNumber = {\n  global: GlobalEventSequenceNumber\n  client: ClientEventSequenceNumber\n  /**\n   * Generation integer that is incremented whenever the client rebased.\n   * Remains constant for all subsequent events until another rebase occurs.\n   */\n  rebaseGeneration: number\n}\n\nexport type EventSequenceNumberInput =\n  | EventSequenceNumber\n  | (Omit<typeof EventSequenceNumber.Encoded, 'rebaseGeneration'> & { rebaseGeneration?: number })\n\n// TODO adjust name to `ClientEventSequenceNumber`\n/**\n * NOTE: Client mutation events with a non-0 client id, won't be synced to the sync backend.\n */\nexport const EventSequenceNumber = Schema.Struct({\n  global: GlobalEventSequenceNumber,\n  /** Only increments for client-local events */\n  client: ClientEventSequenceNumber,\n\n  // TODO also provide a way to see \"confirmation level\" of event (e.g. confirmed by leader/sync backend)\n\n  // Client only\n  rebaseGeneration: Schema.Int,\n}).annotations({\n  title: 'LiveStore.EventSequenceNumber',\n  pretty: () => (seqNum) => toString(seqNum),\n})\n\n/**\n * Compare two event sequence numbers i.e. checks if the first event sequence number is less than the second.\n * Comparison hierarchy: global > client > rebaseGeneration\n */\nexport const compare = (a: EventSequenceNumber, b: EventSequenceNumber) => {\n  if (a.global !== b.global) {\n    return a.global - b.global\n  }\n  if (a.client !== b.client) {\n    return a.client - b.client\n  }\n  return a.rebaseGeneration - b.rebaseGeneration\n}\n\n/**\n * Convert an event sequence number to a string representation.\n *\n * For notation documentation, see: contributor-docs/events-notation.md\n */\nexport const toString = (seqNum: EventSequenceNumber) => {\n  const rebaseGenerationStr = seqNum.rebaseGeneration > 0 ? `r${seqNum.rebaseGeneration}` : ''\n  return seqNum.client === 0\n    ? `e${seqNum.global}${rebaseGenerationStr}`\n    : `e${seqNum.global}.${seqNum.client}${rebaseGenerationStr}`\n}\n\n/**\n * Convert a string representation of an event sequence number to an event sequence number.\n * Parses strings in the format: e{global}[.{client}][r{rebaseGeneration}]\n * Examples: \"e0\", \"e0r1\", \"e0.1\", \"e0.1r1\"\n *\n * For full notation documentation, see: contributor-docs/events-notation.md\n */\nexport const fromString = (str: string): EventSequenceNumber => {\n  if (!str.startsWith('e')) {\n    throw new Error('Invalid event sequence number string: must start with \"e\"')\n  }\n\n  // Remove the 'e' prefix\n  const remaining = str.slice(1)\n\n  // Parse rebase generation if present\n  let rebaseGeneration = rebaseGenerationDefault\n  let withoutRebase = remaining\n  const rebaseMatch = remaining.match(/r(\\d+)$/)\n  if (rebaseMatch !== null) {\n    rebaseGeneration = Number.parseInt(rebaseMatch[1]!, 10)\n    withoutRebase = remaining.slice(0, -rebaseMatch[0].length)\n  }\n\n  // Parse global and client parts\n  const parts = withoutRebase.split('.')\n\n  // Validate that parts contain only digits (and possibly empty for client)\n  if (parts[0] === '' || !/^\\d+$/.test(parts[0]!)) {\n    throw new Error('Invalid event sequence number string: invalid number format')\n  }\n\n  if (parts.length > 1 && parts[1] !== undefined && (parts[1] === '' || !/^\\d+$/.test(parts[1]))) {\n    throw new Error('Invalid event sequence number string: invalid number format')\n  }\n\n  const global = Number.parseInt(parts[0]!, 10)\n  const client = parts.length > 1 && parts[1] !== undefined ? Number.parseInt(parts[1], 10) : 0\n\n  if (Number.isNaN(global) || Number.isNaN(client) || Number.isNaN(rebaseGeneration)) {\n    throw new TypeError('Invalid event sequence number string: invalid number format')\n  }\n\n  return {\n    global: global as any as GlobalEventSequenceNumber,\n    client: client as any as ClientEventSequenceNumber,\n    rebaseGeneration,\n  }\n}\n\nexport const fromGlobal = (seqNum: GlobalEventSequenceNumber) => ({\n  global: seqNum,\n  client: clientDefault,\n  rebaseGeneration: rebaseGenerationDefault,\n})\n\nexport const isEqual = (a: EventSequenceNumber, b: EventSequenceNumber) =>\n  a.global === b.global && a.client === b.client && a.rebaseGeneration === b.rebaseGeneration\n\nexport type EventSequenceNumberPair = { seqNum: EventSequenceNumber; parentSeqNum: EventSequenceNumber }\n\nexport const ROOT = {\n  global: 0 as any as GlobalEventSequenceNumber,\n  client: clientDefault,\n  rebaseGeneration: rebaseGenerationDefault,\n} satisfies EventSequenceNumber\n\nexport const isGreaterThan = (a: EventSequenceNumber, b: EventSequenceNumber) => {\n  return a.global > b.global || (a.global === b.global && a.client > b.client)\n}\n\nexport const isGreaterThanOrEqual = (a: EventSequenceNumber, b: EventSequenceNumber) => {\n  return a.global > b.global || (a.global === b.global && a.client >= b.client)\n}\n\nexport const max = (a: EventSequenceNumber, b: EventSequenceNumber) => {\n  return a.global > b.global || (a.global === b.global && a.client > b.client) ? a : b\n}\n\nexport const diff = (a: EventSequenceNumber, b: EventSequenceNumber) => {\n  return {\n    global: a.global - b.global,\n    client: a.client - b.client,\n  }\n}\n\nexport const make = (seqNum: EventSequenceNumberInput): EventSequenceNumber => {\n  return Schema.is(EventSequenceNumber)(seqNum)\n    ? seqNum\n    : Schema.decodeSync(EventSequenceNumber)({\n        ...seqNum,\n        rebaseGeneration: seqNum.rebaseGeneration ?? rebaseGenerationDefault,\n      })\n}\n\n/**\n * Computes the next event sequence/parent pair.\n */\nexport const nextPair = ({\n  seqNum,\n  isClient,\n  rebaseGeneration,\n}: {\n  seqNum: EventSequenceNumber\n  isClient: boolean\n  rebaseGeneration?: number\n}): EventSequenceNumberPair => {\n  if (isClient) {\n    return {\n      seqNum: {\n        global: seqNum.global,\n        client: (seqNum.client + 1) as any as ClientEventSequenceNumber,\n        rebaseGeneration: rebaseGeneration ?? seqNum.rebaseGeneration,\n      },\n      parentSeqNum: seqNum,\n    }\n  }\n\n  return {\n    seqNum: {\n      global: (seqNum.global + 1) as any as GlobalEventSequenceNumber,\n      client: clientDefault,\n      rebaseGeneration: rebaseGeneration ?? seqNum.rebaseGeneration,\n    },\n    // NOTE we always point to `client: 0` for non-client-local events\n    parentSeqNum: { global: seqNum.global, client: clientDefault, rebaseGeneration: seqNum.rebaseGeneration },\n  }\n}\n","import { memoizeByRef } from '@livestore/utils'\nimport { Option, Schema } from '@livestore/utils/effect'\n\nimport type { EventDef, EventDefRecord } from './EventDef.ts'\nimport * as EventSequenceNumber from './EventSequenceNumber.ts'\nimport type { LiveStoreSchema } from './schema.ts'\n\nexport namespace ForEventDef {\n  export type PartialDecoded<TEventDef extends EventDef.Any> = {\n    name: TEventDef['name']\n    args: Schema.Schema.Type<TEventDef['schema']>\n  }\n\n  export type PartialEncoded<TEventDef extends EventDef.Any> = {\n    name: TEventDef['name']\n    args: Schema.Schema.Encoded<TEventDef['schema']>\n  }\n\n  export type Decoded<TEventDef extends EventDef.Any> = {\n    name: TEventDef['name']\n    args: Schema.Schema.Type<TEventDef['schema']>\n    seqNum: EventSequenceNumber.EventSequenceNumber\n    parentSeqNum: EventSequenceNumber.EventSequenceNumber\n    clientId: string\n    sessionId: string\n  }\n\n  export type Encoded<TEventDef extends EventDef.Any> = {\n    name: TEventDef['name']\n    args: Schema.Schema.Encoded<TEventDef['schema']>\n    seqNum: EventSequenceNumber.EventSequenceNumber\n    parentSeqNum: EventSequenceNumber.EventSequenceNumber\n    clientId: string\n    sessionId: string\n  }\n}\n\nexport type AnyDecoded = ForEventDef.Decoded<EventDef.Any>\nexport const AnyDecoded = Schema.Struct({\n  name: Schema.String,\n  args: Schema.Any,\n  seqNum: EventSequenceNumber.EventSequenceNumber,\n  parentSeqNum: EventSequenceNumber.EventSequenceNumber,\n  clientId: Schema.String,\n  sessionId: Schema.String,\n}).annotations({ title: 'LiveStoreEvent.AnyDecoded' })\n\nexport type AnyEncoded = ForEventDef.Encoded<EventDef.Any>\nexport const AnyEncoded = Schema.Struct({\n  name: Schema.String,\n  args: Schema.Any,\n  seqNum: EventSequenceNumber.EventSequenceNumber,\n  parentSeqNum: EventSequenceNumber.EventSequenceNumber,\n  clientId: Schema.String,\n  sessionId: Schema.String,\n}).annotations({ title: 'LiveStoreEvent.AnyEncoded' })\n\nexport const AnyEncodedGlobal = Schema.Struct({\n  name: Schema.String,\n  args: Schema.Any,\n  seqNum: EventSequenceNumber.GlobalEventSequenceNumber,\n  parentSeqNum: EventSequenceNumber.GlobalEventSequenceNumber,\n  clientId: Schema.String,\n  sessionId: Schema.String,\n}).annotations({ title: 'LiveStoreEvent.AnyEncodedGlobal' })\nexport type AnyEncodedGlobal = typeof AnyEncodedGlobal.Type\n\nexport type PartialAnyDecoded = ForEventDef.PartialDecoded<EventDef.Any>\nexport type PartialAnyEncoded = ForEventDef.PartialEncoded<EventDef.Any>\n\nexport const PartialAnyEncoded = Schema.Struct({\n  name: Schema.String,\n  args: Schema.Any,\n})\n\nexport type PartialForSchema<TSchema extends LiveStoreSchema> = {\n  [K in keyof TSchema['_EventDefMapType']]: ForEventDef.PartialDecoded<TSchema['_EventDefMapType'][K]>\n}[keyof TSchema['_EventDefMapType']]\n\nexport type ForSchema<TSchema extends LiveStoreSchema> = {\n  [K in keyof TSchema['_EventDefMapType']]: ForEventDef.Decoded<TSchema['_EventDefMapType'][K]>\n}[keyof TSchema['_EventDefMapType']]\n\nexport const isPartialEventDef = (event: AnyDecoded | PartialAnyDecoded): event is PartialAnyDecoded =>\n  'num' in event === false && 'parentSeqNum' in event === false\n\nexport type ForEventDefRecord<TEventDefRecord extends EventDefRecord> = Schema.Schema<\n  {\n    [K in keyof TEventDefRecord]: {\n      name: K\n      args: Schema.Schema.Type<TEventDefRecord[K]['schema']>\n      seqNum: EventSequenceNumber.EventSequenceNumber\n      parentSeqNum: EventSequenceNumber.EventSequenceNumber\n      clientId: string\n      sessionId: string\n    }\n  }[keyof TEventDefRecord],\n  {\n    [K in keyof TEventDefRecord]: {\n      name: K\n      args: Schema.Schema.Encoded<TEventDefRecord[K]['schema']>\n      seqNum: EventSequenceNumber.EventSequenceNumber\n      parentSeqNum: EventSequenceNumber.EventSequenceNumber\n      clientId: string\n      sessionId: string\n    }\n  }[keyof TEventDefRecord]\n>\n\nexport type EventDefPartialSchema<TEventDefRecord extends EventDefRecord> = Schema.Schema<\n  {\n    [K in keyof TEventDefRecord]: {\n      name: K\n      args: Schema.Schema.Type<TEventDefRecord[K]['schema']>\n    }\n  }[keyof TEventDefRecord],\n  {\n    [K in keyof TEventDefRecord]: {\n      name: K\n      args: Schema.Schema.Encoded<TEventDefRecord[K]['schema']>\n    }\n  }[keyof TEventDefRecord]\n>\n\nexport const makeEventDefSchema = <TSchema extends LiveStoreSchema>(\n  schema: TSchema,\n): ForEventDefRecord<TSchema['_EventDefMapType']> =>\n  Schema.Union(\n    ...[...schema.eventsDefsMap.values()].map((def) =>\n      Schema.Struct({\n        name: Schema.Literal(def.name),\n        args: def.schema,\n        seqNum: EventSequenceNumber.EventSequenceNumber,\n        parentSeqNum: EventSequenceNumber.EventSequenceNumber,\n        clientId: Schema.String,\n        sessionId: Schema.String,\n      }),\n    ),\n  ).annotations({ title: 'EventDef' }) as any\n\nexport const makeEventDefPartialSchema = <TSchema extends LiveStoreSchema>(\n  schema: TSchema,\n): EventDefPartialSchema<TSchema['_EventDefMapType']> =>\n  Schema.Union(\n    ...[...schema.eventsDefsMap.values()].map((def) =>\n      Schema.Struct({\n        name: Schema.Literal(def.name),\n        args: def.schema,\n      }),\n    ),\n  ).annotations({ title: 'EventDefPartial' }) as any\n\nexport const makeEventDefSchemaMemo = memoizeByRef(makeEventDefSchema)\n\nexport const encodedFromGlobal = (event: AnyEncodedGlobal): AnyEncoded => ({\n  ...event,\n  seqNum: EventSequenceNumber.fromGlobal(event.seqNum),\n  parentSeqNum: EventSequenceNumber.fromGlobal(event.parentSeqNum),\n})\n\n/** Equivalent to AnyEncoded but with a meta field and some convenience methods */\nexport class EncodedWithMeta extends Schema.Class<EncodedWithMeta>('LiveStoreEvent.EncodedWithMeta')({\n  name: Schema.String,\n  args: Schema.Any,\n  seqNum: EventSequenceNumber.EventSequenceNumber,\n  parentSeqNum: EventSequenceNumber.EventSequenceNumber,\n  clientId: Schema.String,\n  sessionId: Schema.String,\n  // TODO get rid of `meta` again by cleaning up the usage implementations\n  meta: Schema.Struct({\n    sessionChangeset: Schema.Union(\n      Schema.TaggedStruct('sessionChangeset', {\n        data: Schema.Uint8Array as any as Schema.Schema<Uint8Array<ArrayBuffer>>,\n        debug: Schema.Any.pipe(Schema.optional),\n      }),\n      Schema.TaggedStruct('no-op', {}),\n      Schema.TaggedStruct('unset', {}),\n    ),\n    syncMetadata: Schema.Option(Schema.JsonValue),\n    /** Used to detect if the materializer is side effecting (during dev) */\n    materializerHashLeader: Schema.Option(Schema.Number),\n    materializerHashSession: Schema.Option(Schema.Number),\n  }).pipe(\n    Schema.mutable,\n    Schema.optional,\n    Schema.withDefaults({\n      constructor: () => ({\n        sessionChangeset: { _tag: 'unset' as const },\n        syncMetadata: Option.none(),\n        materializerHashLeader: Option.none(),\n        materializerHashSession: Option.none(),\n      }),\n      decoding: () => ({\n        sessionChangeset: { _tag: 'unset' as const },\n        syncMetadata: Option.none(),\n        materializerHashLeader: Option.none(),\n        materializerHashSession: Option.none(),\n      }),\n    }),\n  ),\n}) {\n  toJSON = (): any => {\n    // Only used for logging/debugging\n    // - More readable way to print the seqNum + parentSeqNum\n    // - not including `meta`, `clientId`, `sessionId`\n    return {\n      seqNum: `${EventSequenceNumber.toString(this.seqNum)} → ${EventSequenceNumber.toString(this.parentSeqNum)} (${this.clientId}, ${this.sessionId})`,\n      name: this.name,\n      args: this.args,\n    }\n  }\n\n  /**\n   * Example: (global event)\n   * For event e2 → e1 which should be rebased on event e3 → e2\n   * the resulting event num will be e4 → e3\n   *\n   * Example: (client event)\n   * For event e2.1 → e2 which should be rebased on event e3 → e2\n   * the resulting event num will be e3.1 → e3\n   *\n   * Syntax: e2.2 → e2.1\n   *          ^ ^    ^ ^\n   *          | |    | +- client parent number\n   *          | |    +--- global parent number\n   *          | +-- client number\n   *          +---- global number\n   * Client num is omitted for global events\n   */\n  rebase = ({\n    parentSeqNum,\n    isClient,\n    rebaseGeneration,\n  }: {\n    parentSeqNum: EventSequenceNumber.EventSequenceNumber\n    isClient: boolean\n    rebaseGeneration: number\n  }) =>\n    new EncodedWithMeta({\n      ...this,\n      ...EventSequenceNumber.nextPair({ seqNum: parentSeqNum, isClient, rebaseGeneration }),\n    })\n\n  static fromGlobal = (\n    event: AnyEncodedGlobal,\n    meta: {\n      syncMetadata: Option.Option<Schema.JsonValue>\n      materializerHashLeader: Option.Option<number>\n      materializerHashSession: Option.Option<number>\n    },\n  ) =>\n    new EncodedWithMeta({\n      ...event,\n      seqNum: {\n        global: event.seqNum,\n        client: EventSequenceNumber.clientDefault,\n        rebaseGeneration: EventSequenceNumber.rebaseGenerationDefault,\n      },\n      parentSeqNum: {\n        global: event.parentSeqNum,\n        client: EventSequenceNumber.clientDefault,\n        rebaseGeneration: EventSequenceNumber.rebaseGenerationDefault,\n      },\n      meta: {\n        sessionChangeset: { _tag: 'unset' as const },\n        syncMetadata: meta.syncMetadata,\n        materializerHashLeader: meta.materializerHashLeader,\n        materializerHashSession: meta.materializerHashSession,\n      },\n    })\n\n  toGlobal = (): AnyEncodedGlobal => ({\n    ...this,\n    seqNum: this.seqNum.global,\n    parentSeqNum: this.parentSeqNum.global,\n  })\n}\n\n/** NOTE `meta` is not considered for equality */\nexport const isEqualEncoded = (a: AnyEncoded, b: AnyEncoded) =>\n  a.seqNum.global === b.seqNum.global &&\n  a.seqNum.client === b.seqNum.client &&\n  a.name === b.name &&\n  a.clientId === b.clientId &&\n  a.sessionId === b.sessionId &&\n  JSON.stringify(a.args) === JSON.stringify(b.args) // TODO use schema equality here\n","import { Cause, Effect, Layer, Schema, Stream } from '@livestore/utils/effect'\n\nimport * as LiveStoreEvent from './schema/LiveStoreEvent.ts'\n\nexport class UnexpectedError extends Schema.TaggedError<UnexpectedError>()('LiveStore.UnexpectedError', {\n  cause: Schema.Defect,\n  note: Schema.optional(Schema.String),\n  payload: Schema.optional(Schema.Any),\n}) {\n  static mapToUnexpectedError = <A, E, R>(effect: Effect.Effect<A, E, R>) =>\n    effect.pipe(\n      Effect.mapError((cause) => (Schema.is(UnexpectedError)(cause) ? cause : new UnexpectedError({ cause }))),\n      Effect.catchAllDefect((cause) => new UnexpectedError({ cause })),\n    )\n\n  static mapToUnexpectedErrorLayer = <A, E, R>(layer: Layer.Layer<A, E, R>) =>\n    layer.pipe(\n      Layer.catchAllCause((cause) =>\n        Cause.isFailType(cause) && Schema.is(UnexpectedError)(cause.error)\n          ? Layer.fail(cause.error)\n          : Layer.fail(new UnexpectedError({ cause: cause })),\n      ),\n    )\n\n  static mapToUnexpectedErrorStream = <A, E, R>(stream: Stream.Stream<A, E, R>) =>\n    stream.pipe(\n      Stream.mapError((cause) => (Schema.is(UnexpectedError)(cause) ? cause : new UnexpectedError({ cause }))),\n    )\n}\n\nexport class MaterializerHashMismatchError extends Schema.TaggedError<MaterializerHashMismatchError>()(\n  'LiveStore.MaterializerHashMismatchError',\n  {\n    eventName: Schema.String,\n    note: Schema.optionalWith(Schema.String, {\n      default: () => 'Please make sure your event materializer is a pure function without side effects.',\n    }),\n  },\n) {}\n\nexport class IntentionalShutdownCause extends Schema.TaggedError<IntentionalShutdownCause>()(\n  'LiveStore.IntentionalShutdownCause',\n  {\n    reason: Schema.Literal('devtools-reset', 'devtools-import', 'adapter-reset', 'manual'),\n  },\n) {}\n\nexport class StoreInterrupted extends Schema.TaggedError<StoreInterrupted>()('LiveStore.StoreInterrupted', {\n  reason: Schema.String,\n}) {}\n\nexport class SqliteError extends Schema.TaggedError<SqliteError>()('LiveStore.SqliteError', {\n  query: Schema.optional(\n    Schema.Struct({\n      sql: Schema.String,\n      bindValues: Schema.Union(Schema.Record({ key: Schema.String, value: Schema.Any }), Schema.Array(Schema.Any)),\n    }),\n  ),\n  /** The SQLite result code */\n  // code: Schema.optional(Schema.Number),\n  // Added string support for Expo SQLite (we should refactor this to have a unified error type)\n  code: Schema.optional(Schema.Union(Schema.Number, Schema.String)),\n  /** The original SQLite3 error */\n  cause: Schema.Defect,\n  note: Schema.optional(Schema.String),\n}) {}\n\nexport class UnknownEventError extends Schema.TaggedError<UnknownEventError>()('LiveStore.UnknownEventError', {\n  event: LiveStoreEvent.AnyEncoded.pipe(Schema.pick('name', 'args', 'seqNum', 'clientId', 'sessionId')),\n  reason: Schema.Literal('event-definition-missing', 'materializer-missing'),\n  operation: Schema.String,\n  note: Schema.optional(Schema.String),\n}) {}\n\nexport class MaterializeError extends Schema.TaggedError<MaterializeError>()('LiveStore.MaterializeError', {\n  cause: Schema.Union(MaterializerHashMismatchError, SqliteError, UnknownEventError),\n  note: Schema.optional(Schema.String),\n}) {}\n","import { UnexpectedError } from '@livestore/common'\nimport { Effect, Schema, WebChannel } from '@livestore/utils/effect'\nimport * as Webmesh from '@livestore/webmesh'\n\nimport { ServiceWorkerWebmeshEdgePort } from './schemas.js'\n\nexport const connectViaServiceWorker = (\n  webmeshNode: Webmesh.MeshNode<`devtools-panel-${number}` | `contentscript-iframe-${number}`>,\n  tabId: number,\n) =>\n  Effect.gen(function* () {\n    /**\n     * Here we are taking advantage of the fact there are two ways to address the extension background worker.\n     * The regular way is using the chrome.runtime approach, but there is also the approach to address\n     * the extension worker as the service worker. This approach allows us to communicate with the service worker\n     * through a fully-fledged MessagePort which the chrome.runtime protocol doesn't allow.\n     */\n    const swr = yield* Effect.promise(() => navigator.serviceWorker.ready)\n\n    if (swr.active === null) {\n      return yield* UnexpectedError.make({ cause: `No active service worker` })\n    }\n\n    const serviceWorker = swr.active\n\n    const messageChannel = new MessageChannel()\n\n    const [message, transfers] = yield* Schema.encodeWithTransferables(ServiceWorkerWebmeshEdgePort)(\n      ServiceWorkerWebmeshEdgePort.make({\n        source: webmeshNode.nodeName,\n        tabId,\n        port: messageChannel.port1,\n      }),\n    )\n\n    serviceWorker.postMessage(message, transfers)\n\n    const edgeChannel = yield* WebChannel.messagePortChannel({\n      port: messageChannel.port2,\n      schema: Webmesh.WebmeshSchema.Packet,\n    })\n\n    const edgeChannelWithHeartbeat = yield* WebChannel.toOpenChannel(edgeChannel, {\n      heartbeat: { interval: '5 seconds', timeout: '5 seconds' },\n    })\n\n    yield* webmeshNode.addEdge({\n      edgeChannel: edgeChannelWithHeartbeat,\n      target: 'extension-worker',\n      replaceIfExists: true,\n    })\n\n    yield* edgeChannelWithHeartbeat.closedDeferred\n  }).pipe(Effect.withSpan('connectViaServiceWorker'), Effect.scoped, Effect.forever)\n"],"names":["Option.some","Either.right","Brand.nominal","Schema.fromBrand","Schema.Int","Schema.Struct","Schema.String","Schema.Any","EventSequenceNumber.EventSequenceNumber","EventSequenceNumber.GlobalEventSequenceNumber","Schema.Class","Schema.Union","Schema.TaggedStruct","Schema.Uint8Array","Schema.optional","Schema.Option","Schema.JsonValue","Schema.Number","Schema.mutable","Schema.withDefaults","Option.none","EventSequenceNumber.toString","EventSequenceNumber.nextPair","EventSequenceNumber.clientDefault","EventSequenceNumber.rebaseGenerationDefault","Schema.TaggedError","Schema.Defect","Effect.mapError","Schema.is","Effect.catchAllDefect","Layer.catchAllCause","Cause.isFailType","Layer.fail","Stream.mapError","Schema.optionalWith","Schema.Literal","Schema.Record","Schema.Array","LiveStoreEvent.AnyEncoded","Schema.pick","Effect.gen","Effect.promise","Schema.encodeWithTransferables","WebChannel.messagePortChannel","Webmesh.WebmeshSchema.Packet","WebChannel.toOpenChannel","Effect.withSpan","Effect.scoped","Effect.forever"],"mappings":"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","x_google_ignoreList":[0]}
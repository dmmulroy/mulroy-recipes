{"version":3,"file":"contentscript-main-Cna3v8oz.js","sources":["../../../../node_modules/.pnpm/effect@3.18.0/node_modules/effect/dist/esm/FiberMap.js","../../../../submodules/livestore/packages/@livestore/common/src/devtools/devtools-sessioninfo.ts","../../../../submodules/livestore/packages/@livestore/common/src/devtools/mod.ts","../../../../submodules/livestore/packages/@livestore/devtools-web-common/src/web-channel/index.ts","../src/contentscript-main.ts"],"sourcesContent":["import * as Cause from \"./Cause.js\";\nimport * as Deferred from \"./Deferred.js\";\nimport * as Effect from \"./Effect.js\";\nimport * as Exit from \"./Exit.js\";\nimport * as Fiber from \"./Fiber.js\";\nimport * as FiberId from \"./FiberId.js\";\nimport { constFalse, constVoid, dual } from \"./Function.js\";\nimport * as HashSet from \"./HashSet.js\";\nimport * as Inspectable from \"./Inspectable.js\";\nimport * as Iterable from \"./Iterable.js\";\nimport * as MutableHashMap from \"./MutableHashMap.js\";\nimport * as Option from \"./Option.js\";\nimport { pipeArguments } from \"./Pipeable.js\";\nimport * as Predicate from \"./Predicate.js\";\nimport * as Runtime from \"./Runtime.js\";\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport const TypeId = /*#__PURE__*/Symbol.for(\"effect/FiberMap\");\n/**\n * @since 2.0.0\n * @categories refinements\n */\nexport const isFiberMap = u => Predicate.hasProperty(u, TypeId);\nconst Proto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]() {\n    if (this.state._tag === \"Closed\") {\n      return Iterable.empty();\n    }\n    return this.state.backing[Symbol.iterator]();\n  },\n  toString() {\n    return Inspectable.format(this.toJSON());\n  },\n  toJSON() {\n    return {\n      _id: \"FiberMap\",\n      state: this.state\n    };\n  },\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON();\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  }\n};\nconst unsafeMake = (backing, deferred) => {\n  const self = Object.create(Proto);\n  self.state = {\n    _tag: \"Open\",\n    backing\n  };\n  self.deferred = deferred;\n  return self;\n};\n/**\n * A FiberMap can be used to store a collection of fibers, indexed by some key.\n * When the associated Scope is closed, all fibers in the map will be interrupted.\n *\n * You can add fibers to the map using `FiberMap.set` or `FiberMap.run`, and the fibers will\n * be automatically removed from the FiberMap when they complete.\n *\n * @example\n * ```ts\n * import { Effect, FiberMap } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const map = yield* FiberMap.make<string>()\n *\n *   // run some effects and add the fibers to the map\n *   yield* FiberMap.run(map, \"fiber a\", Effect.never)\n *   yield* FiberMap.run(map, \"fiber b\", Effect.never)\n *\n *   yield* Effect.sleep(1000)\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const make = () => Effect.acquireRelease(Effect.map(Deferred.make(), deferred => unsafeMake(MutableHashMap.empty(), deferred)), map => Effect.withFiberRuntime(parent => {\n  const state = map.state;\n  if (state._tag === \"Closed\") return Effect.void;\n  map.state = {\n    _tag: \"Closed\"\n  };\n  return Fiber.interruptAllAs(Iterable.map(state.backing, ([, fiber]) => fiber), FiberId.combine(parent.id(), internalFiberId)).pipe(Effect.intoDeferred(map.deferred));\n}));\n/**\n * Create an Effect run function that is backed by a FiberMap.\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const makeRuntime = () => Effect.flatMap(make(), self => runtime(self)());\n/**\n * Create an Effect run function that is backed by a FiberMap.\n *\n * @since 3.13.0\n * @categories constructors\n */\nexport const makeRuntimePromise = () => Effect.flatMap(make(), self => runtimePromise(self)());\nconst internalFiberIdId = -1;\nconst internalFiberId = /*#__PURE__*/FiberId.make(internalFiberIdId, 0);\nconst isInternalInterruption = /*#__PURE__*/Cause.reduceWithContext(undefined, {\n  emptyCase: constFalse,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: (_, fiberId) => HashSet.has(FiberId.ids(fiberId), internalFiberIdId),\n  sequentialCase: (_, left, right) => left || right,\n  parallelCase: (_, left, right) => left || right\n});\n/**\n * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeSet = /*#__PURE__*/dual(args => isFiberMap(args[0]), (self, key, fiber, options) => {\n  if (self.state._tag === \"Closed\") {\n    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n    return;\n  }\n  const previous = MutableHashMap.get(self.state.backing, key);\n  if (previous._tag === \"Some\") {\n    if (options?.onlyIfMissing === true) {\n      fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n      return;\n    } else if (previous.value === fiber) {\n      return;\n    }\n    previous.value.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));\n  }\n  MutableHashMap.set(self.state.backing, key, fiber);\n  fiber.addObserver(exit => {\n    if (self.state._tag === \"Closed\") {\n      return;\n    }\n    const current = MutableHashMap.get(self.state.backing, key);\n    if (Option.isSome(current) && fiber === current.value) {\n      MutableHashMap.remove(self.state.backing, key);\n    }\n    if (Exit.isFailure(exit) && (options?.propagateInterruption === true ? !isInternalInterruption(exit.cause) : !Cause.isInterruptedOnly(exit.cause))) {\n      Deferred.unsafeDone(self.deferred, exit);\n    }\n  });\n});\n/**\n * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const set = /*#__PURE__*/dual(args => isFiberMap(args[0]), (self, key, fiber, options) => Effect.fiberIdWith(fiberId => Effect.sync(() => unsafeSet(self, key, fiber, {\n  ...options,\n  interruptAs: fiberId\n}))));\n/**\n * Retrieve a fiber from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, key) => self.state._tag === \"Closed\" ? Option.none() : MutableHashMap.get(self.state.backing, key));\n/**\n * Retrieve a fiber from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const get = /*#__PURE__*/dual(2, (self, key) => Effect.suspend(() => unsafeGet(self, key)));\n/**\n * Check if a key exists in the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeHas = /*#__PURE__*/dual(2, (self, key) => self.state._tag === \"Closed\" ? false : MutableHashMap.has(self.state.backing, key));\n/**\n * Check if a key exists in the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const has = /*#__PURE__*/dual(2, (self, key) => Effect.sync(() => unsafeHas(self, key)));\n/**\n * Remove a fiber from the FiberMap, interrupting it if it exists.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const remove = /*#__PURE__*/dual(2, (self, key) => Effect.withFiberRuntime(removeFiber => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.void;\n  }\n  const fiber = MutableHashMap.get(self.state.backing, key);\n  if (fiber._tag === \"None\") {\n    return Effect.void;\n  }\n  // will be removed by the observer\n  return Fiber.interruptAs(fiber.value, FiberId.combine(removeFiber.id(), internalFiberId));\n}));\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const clear = self => Effect.withFiberRuntime(clearFiber => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.void;\n  }\n  return Effect.forEach(self.state.backing, ([, fiber]) =>\n  // will be removed by the observer\n  Fiber.interruptAs(fiber, FiberId.combine(clearFiber.id(), internalFiberId)));\n});\nconst constInterruptedFiber = /*#__PURE__*/function () {\n  let fiber = undefined;\n  return () => {\n    if (fiber === undefined) {\n      fiber = Effect.runFork(Effect.interrupt);\n    }\n    return fiber;\n  };\n}();\n/**\n * Run an Effect and add the forked fiber to the FiberMap.\n * When the fiber completes, it will be removed from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const run = function () {\n  const self = arguments[0];\n  if (Effect.isEffect(arguments[2])) {\n    return runImpl(self, arguments[1], arguments[2], arguments[3]);\n  }\n  const key = arguments[1];\n  const options = arguments[2];\n  return effect => runImpl(self, key, effect, options);\n};\nconst runImpl = (self, key, effect, options) => Effect.fiberIdWith(fiberId => {\n  if (self.state._tag === \"Closed\") {\n    return Effect.interrupt;\n  } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {\n    return Effect.sync(constInterruptedFiber);\n  }\n  return Effect.tap(Effect.forkDaemon(effect), fiber => unsafeSet(self, key, fiber, {\n    ...options,\n    interruptAs: fiberId\n  }));\n});\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.\n *\n * @example\n * ```ts\n * import { Context, Effect, FiberMap } from \"effect\"\n *\n * interface Users {\n *   readonly _: unique symbol\n * }\n * const Users = Context.GenericTag<Users, {\n *    getAll: Effect.Effect<Array<unknown>>\n * }>(\"Users\")\n *\n * Effect.gen(function*() {\n *   const map = yield* FiberMap.make<string>()\n *   const run = yield* FiberMap.runtime(map)<Users>()\n *\n *   // run some effects and add the fibers to the map\n *   run(\"effect-a\", Effect.andThen(Users, _ => _.getAll))\n *   run(\"effect-b\", Effect.andThen(Users, _ => _.getAll))\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const runtime = self => () => Effect.map(Effect.runtime(), runtime => {\n  const runFork = Runtime.runFork(runtime);\n  return (key, effect, options) => {\n    if (self.state._tag === \"Closed\") {\n      return constInterruptedFiber();\n    } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {\n      return constInterruptedFiber();\n    }\n    const fiber = runFork(effect, options);\n    unsafeSet(self, key, fiber, options);\n    return fiber;\n  };\n});\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const runtimePromise = self => () => Effect.map(runtime(self)(), runFork => (key, effect, options) => new Promise((resolve, reject) => runFork(key, effect, options).addObserver(exit => {\n  if (Exit.isSuccess(exit)) {\n    resolve(exit.value);\n  } else {\n    reject(Cause.squash(exit.cause));\n  }\n})));\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const size = self => Effect.sync(() => self.state._tag === \"Closed\" ? 0 : MutableHashMap.size(self.state.backing));\n/**\n * Join all fibers in the FiberMap. If any of the Fiber's in the map terminate with a failure,\n * the returned Effect will terminate with the first failure that occurred.\n *\n * @since 2.0.0\n * @categories combinators\n * @example\n * ```ts\n * import { Effect, FiberMap } from \"effect\";\n *\n * Effect.gen(function* (_) {\n *   const map = yield* _(FiberMap.make());\n *   yield* _(FiberMap.set(map, \"a\", Effect.runFork(Effect.fail(\"error\"))));\n *\n *   // parent fiber will fail with \"error\"\n *   yield* _(FiberMap.join(map));\n * });\n * ```\n */\nexport const join = self => Deferred.await(self.deferred);\n/**\n * Wait for the FiberMap to be empty.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const awaitEmpty = self => Effect.whileLoop({\n  while: () => self.state._tag === \"Open\" && MutableHashMap.size(self.state.backing) > 0,\n  body: () => Fiber.await(Iterable.unsafeHead(self)[1]),\n  step: constVoid\n});\n//# sourceMappingURL=FiberMap.js.map","import type { ParseResult, Scope, WebChannel } from '@livestore/utils/effect'\nimport {\n  Data,\n  Duration,\n  Effect,\n  FiberMap,\n  HashSet,\n  Schedule,\n  Schema,\n  Stream,\n  Subscribable,\n  SubscriptionRef,\n} from '@livestore/utils/effect'\n\nexport const RequestSessions = Schema.TaggedStruct('RequestSessions', {})\nexport type RequestSessions = typeof RequestSessions.Type\n\nexport const SessionInfo = Schema.TaggedStruct('SessionInfo', {\n  storeId: Schema.String,\n  clientId: Schema.String,\n  sessionId: Schema.String,\n  schemaAlias: Schema.String,\n  isLeader: Schema.Boolean,\n  /**\n   * Browser origin that produced this SessionInfo (for example, 'http://localhost:5173').\n   * Set by browser-based publishers so DevTools can defensively filter by origin.\n   * Currently only needed by the browser extension; non‑browser publishers typically set `undefined`.\n   */\n  origin: Schema.UndefinedOr(Schema.String),\n})\nexport type SessionInfo = typeof SessionInfo.Type\n\nexport const Message = Schema.Union(RequestSessions, SessionInfo)\nexport type Message = typeof Message.Type\n\n/** Usually called in client session */\nexport const provideSessionInfo = ({\n  webChannel,\n  sessionInfo,\n}: {\n  webChannel: WebChannel.WebChannel<Message, Message>\n  sessionInfo: SessionInfo\n}): Effect.Effect<void, ParseResult.ParseError> =>\n  Effect.gen(function* () {\n    yield* webChannel.send(sessionInfo)\n\n    yield* webChannel.listen.pipe(\n      Stream.flatten(),\n      Stream.filter(Schema.is(RequestSessions)),\n      Stream.tap(() => webChannel.send(sessionInfo)),\n      Stream.runDrain,\n    )\n  })\n\n/** Usually called in devtools */\nexport const requestSessionInfoSubscription = ({\n  webChannel,\n  pollInterval = Duration.seconds(1),\n  staleTimeout = Duration.seconds(5),\n}: {\n  webChannel: WebChannel.WebChannel<Message, Message>\n  pollInterval?: Duration.DurationInput\n  staleTimeout?: Duration.DurationInput\n}): Effect.Effect<Subscribable.Subscribable<Set<SessionInfo>>, ParseResult.ParseError, Scope.Scope> =>\n  Effect.gen(function* () {\n    yield* webChannel\n      .send(RequestSessions.make({}))\n      .pipe(\n        Effect.repeat(Schedule.spaced(pollInterval)),\n        Effect.interruptible,\n        Effect.tapCauseLogPretty,\n        Effect.forkScoped,\n      )\n\n    const timeoutFiberMap = yield* FiberMap.make<SessionInfo>()\n\n    const sessionInfoSubRef = yield* SubscriptionRef.make<HashSet.HashSet<SessionInfo>>(HashSet.empty())\n\n    yield* webChannel.listen.pipe(\n      Stream.flatten(),\n      Stream.filter(Schema.is(SessionInfo)),\n      Stream.map(Data.struct),\n      Stream.tap(\n        Effect.fn(function* (sessionInfo) {\n          yield* SubscriptionRef.getAndUpdate(sessionInfoSubRef, HashSet.add(sessionInfo))\n\n          // Remove sessionInfo from cache after staleTimeout (unless a new identical item resets the timeout)\n          yield* FiberMap.run(\n            timeoutFiberMap,\n            sessionInfo,\n            Effect.gen(function* () {\n              yield* Effect.sleep(staleTimeout)\n              yield* SubscriptionRef.getAndUpdate(sessionInfoSubRef, HashSet.remove(sessionInfo))\n            }),\n          )\n        }),\n      ),\n      Stream.runDrain,\n      Effect.tapCauseLogPretty,\n      Effect.forkScoped,\n    )\n\n    return Subscribable.make({\n      get: sessionInfoSubRef.get.pipe(Effect.map((sessionInfos) => new Set(sessionInfos))),\n      changes: sessionInfoSubRef.changes.pipe(Stream.map((sessionInfos) => new Set(sessionInfos))),\n    })\n  })\n","import type { Effect, Scope, WebChannel } from '@livestore/utils/effect'\nimport { Schema } from '@livestore/utils/effect'\nimport { nanoid } from '@livestore/utils/nanoid'\nimport type { MeshNode } from '@livestore/webmesh'\n\nimport * as SessionInfo from './devtools-sessioninfo.ts'\n\nexport * from './devtools-messages.ts'\nexport * as SessionInfo from './devtools-sessioninfo.ts'\n\nexport const DevtoolsMode = Schema.Union(\n  Schema.TaggedStruct('node', {\n    /** WebSocket URL */\n    url: Schema.String,\n  }),\n  Schema.TaggedStruct('web', {}),\n  Schema.TaggedStruct('browser-extension', {}),\n)\n\nexport type DevtoolsMode = typeof DevtoolsMode.Type\n\nexport const DevtoolsModeTag = DevtoolsMode.pipe(Schema.pluck('_tag'), Schema.typeSchema)\nexport type DevtoolsModeTag = typeof DevtoolsModeTag.Type\n\nexport const makeNodeName = {\n  devtools: {\n    random: () => `devtools-instance-${nanoid()}`,\n  },\n  client: {\n    session: ({ storeId, clientId, sessionId }: { storeId: string; clientId: string; sessionId: string }) =>\n      `client-session-${storeId}-${clientId}-${sessionId}`,\n    leader: ({ storeId, clientId }: { storeId: string; clientId: string }) => `client-leader-${storeId}-${clientId}`,\n  },\n}\n\nexport const makeChannelName = {\n  /**\n   * SessionInfo channel for DevTools discovery.\n   * When an `origin` is provided, it is incorporated into the channel name to scope\n   * broadcasts per origin (e.g. `session-info::http%3A%2F%2Flocalhost%3A5173`).\n   * The `origin` is currently required only for the browser extension path; non‑browser\n   * publishers can pass `undefined` to use the legacy global channel name.\n   */\n  sessionInfo: ({ origin }: { origin: string | undefined }) =>\n    origin ? `session-info::${encodeURIComponent(origin)}` : `session-info`,\n  devtoolsClientSession: ({ storeId, clientId, sessionId }: { storeId: string; clientId: string; sessionId: string }) =>\n    `devtools-channel(client-session-${storeId}-${clientId}-${sessionId})`,\n  devtoolsClientLeader: ({ storeId, clientId, sessionId }: { storeId: string; clientId: string; sessionId: string }) =>\n    `devtools-channel(client-leader-${storeId}-${clientId}-${sessionId})`,\n}\n\nexport const isChannelName = {\n  devtoolsClientSession: (\n    channelName: string,\n    { storeId, clientId, sessionId }: { storeId: string; clientId: string; sessionId: string },\n  ) => channelName === makeChannelName.devtoolsClientSession({ storeId, clientId, sessionId }),\n  devtoolsClientLeader: (channelName: string, { storeId, clientId }: { storeId: string; clientId: string }) =>\n    channelName.startsWith(`devtools-channel(client-leader-${storeId}-${clientId}`),\n}\n\nexport const makeSessionInfoBroadcastChannel = (\n  webmeshNode: MeshNode,\n  options: { origin: string | undefined },\n): Effect.Effect<WebChannel.WebChannel<SessionInfo.Message, SessionInfo.Message>, never, Scope.Scope> =>\n  webmeshNode.makeBroadcastChannel({\n    channelName: makeChannelName.sessionInfo({ origin: options?.origin }),\n    schema: SessionInfo.Message,\n  })\n","import { Devtools, UnexpectedError } from '@livestore/common'\nimport { LS_DEV } from '@livestore/utils'\nimport type { Scope, Worker } from '@livestore/utils/effect'\nimport { Deferred, Effect, Schema, Stream, WebChannel } from '@livestore/utils/effect'\nimport type { MeshNode } from '@livestore/webmesh'\nimport { WebmeshSchema } from '@livestore/webmesh'\n\nimport * as WorkerSchema from '../worker/schema.ts'\n\nexport * as WorkerSchema from '../worker/schema.ts'\n\ndeclare global {\n  var __debugWebmeshNode: any\n}\n\nexport const makeSessionInfoBroadcastChannel: Effect.Effect<\n  WebChannel.WebChannel<Devtools.SessionInfo.Message, Devtools.SessionInfo.Message>,\n  UnexpectedError,\n  Scope.Scope\n> = WebChannel.broadcastChannel({\n  channelName: 'session-info',\n  schema: Devtools.SessionInfo.Message,\n})\n\nexport const makeNodeName = {\n  sharedWorker: ({ storeId }: { storeId: string }) => `shared-worker-${storeId}`,\n  // TODO refactor shared-worker setup so there's only a single shared-worker per origin\n  // sharedWorker: () => `shared-worker`,\n  browserExtension: {\n    contentscriptMain: (tabId: number) => `contentscript-main-${tabId}`,\n    contentscriptIframe: (tabId: number) => `contentscript-iframe-${tabId}`,\n  },\n}\n\nexport const ClientSessionContentscriptMainReq = Schema.TaggedStruct('ClientSessionContentscriptMainReq', {\n  storeId: Schema.String,\n  clientId: Schema.String,\n  sessionId: Schema.String,\n})\n\nexport const ClientSessionContentscriptMainRes = Schema.TaggedStruct('ClientSessionContentscriptMainRes', {\n  tabId: Schema.Number,\n})\n\n// Effect.suspend is needed since `window` is not available in the shared worker\nexport const makeStaticClientSessionChannel = {\n  contentscriptMain: Effect.suspend(() =>\n    WebChannel.windowChannel({\n      listenWindow: window,\n\n      sendWindow: window,\n      schema: { listen: ClientSessionContentscriptMainReq, send: ClientSessionContentscriptMainRes },\n      ids: { own: 'contentscript-main-static', other: 'client-session-static' },\n    }),\n  ),\n  clientSession: Effect.suspend(() =>\n    WebChannel.windowChannel({\n      listenWindow: window,\n\n      sendWindow: window,\n      schema: { listen: ClientSessionContentscriptMainRes, send: ClientSessionContentscriptMainReq },\n      ids: { own: 'client-session-static', other: 'contentscript-main-static' },\n    }),\n  ),\n}\n\nexport const connectViaWorker = ({\n  node,\n  target,\n  worker,\n}: {\n  node: MeshNode\n  target: string\n  worker: Worker.SerializedWorkerPool<typeof WorkerSchema.Request.Type>\n}) =>\n  Effect.gen(function* () {\n    const mc = new MessageChannel()\n\n    const isConnected = yield* Deferred.make<boolean, never>()\n\n    if (LS_DEV) {\n      yield* Effect.addFinalizerLog(\n        `@livestore/devtools-web-common: closing message channel ${node.nodeName} → ${target}`,\n      )\n    }\n\n    yield* worker.execute(WorkerSchema.CreateConnection.make({ from: node.nodeName, port: mc.port1 })).pipe(\n      Stream.tap(() => Deferred.succeed(isConnected, true)),\n      Stream.runDrain,\n      Effect.tapCauseLogPretty,\n      Effect.forkScoped,\n    )\n\n    yield* isConnected\n\n    const sharedWorkerConnection = yield* WebChannel.messagePortChannel({\n      port: mc.port2,\n      schema: WebmeshSchema.Packet,\n    })\n\n    yield* node.addEdge({ target, edgeChannel: sharedWorkerConnection, replaceIfExists: true })\n\n    if (LS_DEV) {\n      yield* Effect.logDebug(`@livestore/devtools-web-common: initiated connection: ${node.nodeName} → ${target}`)\n    }\n  }).pipe(UnexpectedError.mapToUnexpectedError)\n","import { Devtools } from '@livestore/common'\nimport { ChromeExtension } from '@livestore/devtools-common'\nimport * as DevtoolsWeb from '@livestore/devtools-web-common/web-channel'\nimport { shouldNeverHappen } from '@livestore/utils'\nimport { Effect, FiberMap, Logger, LogLevel, Schema, Stream, WebChannel } from '@livestore/utils/effect'\nimport * as Webmesh from '@livestore/webmesh'\n\nimport { BUILD_NUMBER } from './buildnumber.js'\nimport { ContentscriptIframeSearchParamsSchema } from './schemas.js'\n\n/**\n * The main purpose of this contentscript to facilitate a connection between the app client session\n * and the devtools React app. We already have a Webmesh edge to the app client session via the `window`\n * and addditionally this contentscript helps in this process by starting an iframe\n * with the extension origin which can then establish a Webmesh MessageChannel with the\n * extension background worker via `navigator.serviceWorker`.\n */\nEffect.gen(function* () {\n  // We don't want to run the contentscript in the devtools themselves in case they are opened in the app origin\n  if (document.querySelector('meta[name=\"livestore-devtools\"]')) {\n    // TODO show a message to the user that the devtools are running in the app origin\n    return\n  }\n\n  // TODO make sure `contentscript-main` is not already running for the current tab\n  // in that case, we should just return\n\n  // Get the tabId of the current tab from the extension background worker which is used\n  // to scope the webmesh network to the current tab\n  const tabId = yield* Effect.async<number>((cb) => {\n    const connection = chrome.runtime.connect()\n    const listener = (message: { type: string; tabId: number }) => {\n      if (message.type === 'tabId') {\n        connection.onMessage.removeListener(listener)\n        connection.disconnect()\n        cb(Effect.succeed(message.tabId))\n      }\n    }\n    connection.onMessage.addListener(listener)\n    connection.postMessage({ type: 'getTabId' })\n  })\n\n  const webmeshNode = yield* Webmesh.makeMeshNode(ChromeExtension.makeNodeName.contentscriptMain({ tabId }))\n\n  yield* connectViaIframe(webmeshNode, tabId)\n\n  const fiberMap = yield* FiberMap.make<string>()\n\n  const clientSessionStaticChannel = yield* DevtoolsWeb.makeStaticClientSessionChannel.contentscriptMain\n\n  const connect = ({ clientId, sessionId, storeId }: typeof DevtoolsWeb.ClientSessionContentscriptMainReq.Type) =>\n    Effect.gen(function* () {\n      yield* clientSessionStaticChannel.send(DevtoolsWeb.ClientSessionContentscriptMainRes.make({ tabId }))\n\n      const clientSessionNodeName = Devtools.makeNodeName.client.session({\n        storeId,\n        clientId,\n        sessionId,\n      })\n\n      const clientSessionChannel = yield* WebChannel.windowChannel({\n        // eslint-disable-next-line unicorn/prefer-global-this\n        listenWindow: window,\n        // eslint-disable-next-line unicorn/prefer-global-this\n        sendWindow: window,\n        schema: Webmesh.WebmeshSchema.Packet,\n        ids: { own: webmeshNode.nodeName, other: clientSessionNodeName },\n      })\n\n      yield* webmeshNode\n        .addEdge({\n          target: clientSessionNodeName,\n          edgeChannel: clientSessionChannel,\n          replaceIfExists: true,\n        })\n        .pipe(Effect.acquireRelease(() => webmeshNode.removeEdge(clientSessionNodeName).pipe(Effect.orDie)))\n\n      return yield* Effect.never\n    }).pipe(Effect.tapCauseLogPretty, FiberMap.run(fiberMap, `${storeId}-${clientId}-${sessionId}`))\n\n  yield* clientSessionStaticChannel.listen.pipe(Stream.flatten(), Stream.tap(connect), Stream.runDrain)\n}).pipe(\n  Effect.withSpan('LSD:contentscript-main'),\n  Effect.scoped,\n  Effect.tapCauseLogPretty,\n  Effect.annotateLogs({\n    thread: 'contentscript-main',\n    origin: 'app',\n    BUILD_NUMBER,\n  }),\n  Effect.provide(Logger.prettyWithThread('window(contentscript-main)')),\n  Logger.withMinimumLogLevel(LogLevel.Debug),\n  Effect.runFork,\n)\n\nconst connectViaIframe = (webmeshNode: Webmesh.MeshNode, tabId: number) =>\n  Effect.gen(function* () {\n    const id = `livestore-devtools-iframe-${BUILD_NUMBER}`\n    if (document.getElementById(id)) {\n      shouldNeverHappen(`[@livestore/devtools-chrome:contentscript-main] iframe already exists`)\n    }\n\n    const el = document.createElement('div')\n    el.id = id\n\n    const root = el.attachShadow({ mode: 'closed' })\n\n    const iframe = document.createElement('iframe')\n    iframe.hidden = true\n\n    root.append(iframe)\n    ;(document.body ?? document.documentElement).append(el)\n\n    const searchParamsEntries = yield* Schema.encode(ContentscriptIframeSearchParamsSchema)(\n      ContentscriptIframeSearchParamsSchema.make({\n        // The secret is used for security reasons so no one else can connect to the iframe\n        secret: Math.random().toString(36),\n        tabId,\n      }),\n    )\n\n    yield* Effect.async((cb) => {\n      iframe.addEventListener('load', () => cb(Effect.void))\n      iframe.addEventListener('error', (e) => cb(Effect.die(e)))\n\n      const url = new URL(chrome.runtime.getURL(`/contentscript-iframe-${BUILD_NUMBER}.html`))\n\n      for (const [key, value] of Object.entries(searchParamsEntries)) {\n        url.searchParams.set(key, value)\n      }\n\n      iframe.contentWindow!.location.href = url.toString()\n    })\n\n    const contentscriptIframeNodeName = ChromeExtension.makeNodeName.contentscriptIframe({ tabId })\n\n    const iframeChannel = yield* WebChannel.windowChannel({\n      // eslint-disable-next-line unicorn/prefer-global-this\n      listenWindow: window,\n      sendWindow: iframe.contentWindow!,\n      schema: Webmesh.WebmeshSchema.Packet,\n      ids: { own: webmeshNode.nodeName, other: contentscriptIframeNodeName },\n    })\n\n    yield* webmeshNode.addEdge({\n      target: contentscriptIframeNodeName,\n      edgeChannel: iframeChannel,\n    })\n  })\n"],"names":["Predicate.hasProperty","Iterable.empty","Inspectable.format","Inspectable.NodeInspectSymbol","Effect.acquireRelease","Effect.map","Deferred.make","MutableHashMap.empty","map","Effect.withFiberRuntime","Effect.void","Fiber.interruptAllAs","Iterable.map","FiberId.combine","Effect.intoDeferred","FiberId.make","Cause.reduceWithContext","HashSet.has","FiberId.ids","FiberId.none","MutableHashMap.get","MutableHashMap.set","Option.isSome","MutableHashMap.remove","Exit.isFailure","Cause.isInterruptedOnly","Deferred.unsafeDone","MutableHashMap.has","Effect.runFork","Effect.interrupt","Effect.isEffect","Effect.fiberIdWith","Effect.sync","Effect.tap","Effect.forkDaemon","Schema.TaggedStruct","Schema.String","Schema.Boolean","Schema.UndefinedOr","Schema.Union","Schema.pluck","Schema.typeSchema","WebChannel.broadcastChannel","Devtools.SessionInfo.Message","Schema.Number","Effect.suspend","WebChannel.windowChannel","Effect.gen","Effect.async","Effect.succeed","Webmesh.makeMeshNode","ChromeExtension.makeNodeName","FiberMap.make","DevtoolsWeb.makeStaticClientSessionChannel","DevtoolsWeb.ClientSessionContentscriptMainRes","Devtools.makeNodeName","Webmesh.WebmeshSchema.Packet","Effect.orDie","Effect.never","Effect.tapCauseLogPretty","FiberMap.run","Stream.flatten","Stream.tap","Stream.runDrain","Effect.withSpan","Effect.scoped","Effect.annotateLogs","Effect.provide","Logger.prettyWithThread","Logger.withMinimumLogLevel","LogLevel.Debug","Schema.encode","Effect.die"],"mappings":"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","x_google_ignoreList":[0]}
{"version":3,"file":"background.js","sources":["../src/background.ts"],"sourcesContent":["/// <reference lib=\"webworker\" />\n\nimport { ChromeExtension, CopyToClipboard } from '@livestore/devtools-common'\nimport type { Scope } from '@livestore/utils/effect'\nimport { Effect, Logger, LogLevel, Runtime, Schema, Stream, WebChannel } from '@livestore/utils/effect'\nimport * as Webmesh from '@livestore/webmesh'\n\nimport { BUILD_NUMBER } from './buildnumber.js'\nimport { ServiceWorkerWebmeshEdgePort } from './schemas.js'\n\nEffect.gen(function* () {\n  // yield* Effect.logDebug(`[@livestore/devtools-chrome:background] booted (${BUILD_NUMBER})`)\n\n  const runtime = yield* Effect.runtime<Scope.Scope>()\n\n  const webmeshNode = yield* Webmesh.makeMeshNode(ChromeExtension.makeNodeName.extensionWorker())\n  globalThis.__debugWebmeshNode = webmeshNode\n\n  // Service worker handler\n  self.addEventListener('message', (e) =>\n    Effect.gen(function* () {\n      // yield* Effect.logDebug(`[@livestore/devtools-chrome:background] onmessage: ${e.data._tag}`, e)\n\n      const decodedMessageRes = Schema.decodeOption(ServiceWorkerWebmeshEdgePort)(e.data)\n      if (decodedMessageRes._tag === 'None') return\n\n      const { port, source, tabId } = decodedMessageRes.value\n\n      // Will be called multiple times for the same tabId from: contentscript-iframe + devtools-panel\n      return yield* Effect.gen(function* () {\n        const edgeChannel = yield* WebChannel.messagePortChannel({ port, schema: Webmesh.WebmeshSchema.Packet })\n        const edgeChannelWithHeartbeat = yield* WebChannel.toOpenChannel(edgeChannel, {\n          heartbeat: { interval: '5 seconds', timeout: '5 seconds' },\n        })\n\n        yield* webmeshNode.addEdge({ edgeChannel: edgeChannelWithHeartbeat, target: source, replaceIfExists: true })\n\n        if (\n          (yield* webmeshNode.hasChannel({\n            target: ChromeExtension.makeNodeName.devtools({ tabId }),\n            channelName: ChromeExtension.makeChannelName.clipboard({ tabId }),\n          })) === false\n        ) {\n          yield* listenForClipboardMessages({ webmeshNode, tabId }).pipe(Effect.tapCauseLogPretty, Effect.forkScoped)\n        }\n\n        // TODO possibly handle shutdown of connections e.g. if a client goes away\n        return yield* Effect.never\n      })\n    }).pipe(\n      Effect.withSpan('[@livestore/devtools-chrome:background] service worker handler'),\n      Effect.tapCauseLogPretty,\n      Runtime.runFork(runtime),\n    ),\n  )\n\n  chrome.runtime.onConnect.addListener((connection) => {\n    connection.onMessage.addListener((message) => {\n      // Needed in `contentscript-main` to get the tabId\n      if (message.type === 'getTabId') {\n        connection.postMessage({ type: 'tabId', tabId: connection.sender!.tab!.id! })\n      } else if (message.type === 'keepAlive') {\n        // Do nothing\n      } else {\n        console.warn(`[@livestore/devtools-chrome:background] unknown message type`, message)\n      }\n    })\n  })\n\n  let offscreenDocCreated = false\n\n  const listenForClipboardMessages = ({ webmeshNode, tabId }: { webmeshNode: Webmesh.MeshNode; tabId: number }) =>\n    Effect.gen(function* () {\n      const devtoolsChannel = yield* webmeshNode.makeChannel({\n        target: ChromeExtension.makeNodeName.devtools({ tabId }),\n        channelName: ChromeExtension.makeChannelName.clipboard({ tabId }),\n        schema: { send: Schema.Void, listen: CopyToClipboard },\n        mode: 'direct',\n      })\n\n      const addToClipboard = (value: string) =>\n        Effect.promise(async () => {\n          if (offscreenDocCreated === false) {\n            await chrome.offscreen.createDocument({\n              url: 'offscreen-for-clipboard.html',\n              reasons: [chrome.offscreen.Reason.CLIPBOARD],\n              justification: 'Write text to the clipboard.',\n            })\n\n            offscreenDocCreated = true\n          }\n\n          // Now that we have an offscreen document, we can dispatch the message.\n          await chrome.runtime.sendMessage({\n            type: 'copy-data-to-clipboard',\n            target: 'offscreen-doc',\n            data: value,\n          })\n        })\n\n      yield* devtoolsChannel.listen\n        .pipe(\n          Stream.flatten(),\n          Stream.tap((msg) => addToClipboard(msg.text)),\n        )\n        .pipe(Stream.runDrain)\n    })\n\n  return yield* Effect.never\n}).pipe(\n  Effect.withSpan('@livestore/devtools-chrome:background:main'),\n  Effect.scoped,\n  Effect.tapCauseLogPretty,\n  Effect.annotateLogs({ thread: 'background', origin: 'extension', BUILD_NUMBER }),\n  Effect.provide(Logger.prettyWithThread('background')),\n  Logger.withMinimumLogLevel(LogLevel.Debug),\n  Effect.runFork,\n)\n"],"names":["Effect.gen","runtime","Effect.runtime","Webmesh.makeMeshNode","ChromeExtension.makeNodeName","Schema.decodeOption","WebChannel.messagePortChannel","Webmesh.WebmeshSchema.Packet","WebChannel.toOpenChannel","ChromeExtension.makeChannelName","Effect.tapCauseLogPretty","Effect.forkScoped","Effect.never","Effect.withSpan","Runtime.runFork","webmeshNode","Schema.Void","Effect.promise","Stream.flatten","Stream.tap","Stream.runDrain","Effect.scoped","Effect.annotateLogs","Effect.provide","Logger.prettyWithThread","Logger.withMinimumLogLevel","LogLevel.Debug","Effect.runFork"],"mappings":"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"}